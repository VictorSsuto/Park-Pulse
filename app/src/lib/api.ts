// app/src/lib/api.ts
export type Crowd = "low" | "medium" | "high";

export type MapParkPoint = {
  ParkName: string;
  Year: number;
  Month: number;
  predicted_visits: number;
  crowd_level: Crowd;
  Latitude: number;
  Longitude: number;
};

export type MapByIndex = {
  baseYear: number;
  baseMonth: number;
  months: { index: number; parks: MapParkPoint[] }[];
};

export type ForecastRow = {
  Year: number;
  Month: number;
  predicted_visits: number;
  crowd_level: Crowd;
  low_threshold?: number;
  high_threshold?: number;
};

export type ForecastResponse = {
  park: string;
  months: number;
  forecast: ForecastRow[];
};

/** New: parks index item generated by build_parks_index.py */
export type ParksIndexItem = {
  name: string;
  slug: string;
  lat: number;
  lng: number;
};

/**
 * Fetch helper that works in client components.
 * (We are using public/ JSON files, so we fetch relative paths.)
 */
async function fetchJSON<T>(path: string): Promise<T> {
  const res = await fetch(path, { cache: "no-store" });
  if (!res.ok) {
    const txt = await res.text().catch(() => "");
    throw new Error(`GET ${path} failed (${res.status}): ${txt || res.statusText}`);
  }
  return (await res.json()) as T;
}

/**
 * Canonical slug: matches your forecast filenames:
 *  - big-bend.json
 *  - wrangell-st-elias.json
 *  - mount-rainier.json
 */
export function parkSlug(input: string): string {
  return String(input ?? "")
    .trim()
    .toLowerCase()
    .replace(/[–—]/g, "-")
    .replace(/['ʻ’]/g, "")
    .replace(/[.]/g, "")
    .replace(/[^a-z0-9]+/g, "-")
    .replace(/(^-|-$)/g, "");
}

/**
 * NEW: parks_index.json should be:
 * [{ "name": "Acadia", "slug": "acadia", "lat": 44.33, "lng": -68.27 }, ...]
 */
export async function getParksIndex(): Promise<ParksIndexItem[]> {
  const data = await fetchJSON<unknown>("/data/parks_index.json");

  if (!Array.isArray(data)) {
    throw new Error("Invalid /data/parks_index.json format. Expected ParkIndexItem[]");
  }

  const normalized = (data as any[])
    .map((p) => ({
      name: String(p?.name ?? "").trim(),
      slug: String(p?.slug ?? "").trim(),
      lat: Number(p?.lat),
      lng: Number(p?.lng),
    }))
    .filter((p) => p.name && p.slug && Number.isFinite(p.lat) && Number.isFinite(p.lng))
    .sort((a, b) => a.name.localeCompare(b.name));

  return normalized;
}

/**
 * Back-compat: return string[] of park names.
 * IMPORTANT: now sourced from parks_index.json (NOT parks.json),
 * so no typos / missing parks.
 */
export async function getParks(): Promise<string[]> {
  const index = await getParksIndex();
  return index.map((p) => p.name);
}

export async function getMapByIndex(): Promise<MapByIndex> {
  const data = await fetchJSON<MapByIndex>("/data/map_by_index.json");

  if (!data || !Array.isArray(data.months)) {
    throw new Error("Invalid /data/map_by_index.json format. Expected { baseYear, baseMonth, months[] }");
  }

  return data;
}

/**
 * Forecast files live at:
 * /public/data/forecasts/<slug>.json
 *
 * Now that your forecasts folder is standardized, we only fetch:
 * /data/forecasts/${parkSlug(nameOrSlug)}.json
 */
export async function getForecast(parkNameOrSlug: string): Promise<ForecastResponse> {
  const raw = String(parkNameOrSlug ?? "").trim();
  if (!raw) throw new Error("parkName is required");

  const slug = parkSlug(raw);
  const path = `/data/forecasts/${slug}.json`;

  const data = await fetchJSON<ForecastResponse>(path);
  if (!data || !Array.isArray(data.forecast)) {
    throw new Error(`Invalid forecast format in ${path}`);
  }

  return data;
}


// Backwards-compat aliases (so old imports don’t break)
export const getForecastForPark = getForecast;
export const getParkNames = getParks;
